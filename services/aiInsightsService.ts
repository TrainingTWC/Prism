/**
 * AI Insights Service
 * Analyzes HR Connect survey remarks and generates positive/negative insights
 */

import { aiRequestQueue } from './requestQueue';

/**
 * Removes duplicate insights based on similar summary text
 */
function removeDuplicates(items: any[]): any[] {
  const seen = new Set<string>();
  const unique: any[] = [];
  
  for (const item of items) {
    const summary = typeof item === 'string' ? item : item.summary;
    const normalizedSummary = summary.toLowerCase().trim();
    
    // Check if we've seen a very similar summary
    let isDuplicate = false;
    for (const seenSummary of seen) {
      // Check for exact match or very high similarity
      if (normalizedSummary === seenSummary || 
          normalizedSummary.includes(seenSummary) || 
          seenSummary.includes(normalizedSummary)) {
        isDuplicate = true;
        break;
      }
    }
    
    if (!isDuplicate) {
      seen.add(normalizedSummary);
      unique.push(item);
    }
  }
  
  return unique;
}

interface DetailedInsight {
  summary: string;
  explanation: string;
}

interface InsightResult {
  positives: string[];
  negatives: string[];
  isAiGenerated: boolean; // Indicates if insights were generated by AI or fallback analysis
  detailedInsights?: {
    positives: DetailedInsight[];
    negatives: DetailedInsight[];
  };
}

/**
 * Analyzes submission remarks using AI to generate insights
 * @param submissions - Array of submissions to analyze
 * @returns Promise with positive and negative insights
 */
export async function generateAMInsights(submissions: any[]): Promise<InsightResult> {
  try {
    // ALWAYS use fallback - AI disabled due to rate limits and reliability issues
    console.log('üìä Using enhanced fallback analysis with training data (AI disabled)');
    
    // Collect all remarks from submissions for analysis
    const remarks: string[] = [];
    
    submissions.forEach((sub: any) => {
      // Collect question remarks (q1_remarks through q12_remarks)
      for (let i = 1; i <= 12; i++) {
        const remarkKey = `q${i}_remarks`;
        const remark = sub[remarkKey];
        if (remark && String(remark).trim().length > 5) {
          remarks.push(String(remark).trim());
        }
      }
      
      // Also check for q11 (suggestions) which is a textarea
      if (sub.q11 && String(sub.q11).trim().length > 5) {
        remarks.push(String(sub.q11).trim());
      }
    });

    // Always use fallback analysis with training data integration (reliable and fast)
    return await generateFallbackInsights(submissions);
    
  } catch (error) {
    console.error('Error generating insights:', error);
    // Return fallback insights
    return await generateFallbackInsights(submissions);
  }
}

/**
 * Analyzes remarks using AI (GitHub Models or local analysis)
 */
async function analyzeWithAI(remarks: string[], submissions: any[]): Promise<InsightResult> {
  // GitHub token should be set via environment variable VITE_GITHUB_TOKEN
  const githubToken = import.meta.env.VITE_GITHUB_TOKEN || '';
  
  console.log('üîç Checking GitHub token availability:', githubToken ? '‚úÖ Token found' : '‚ùå No token found');
  
  if (githubToken && githubToken.length > 10) {
    try {
      console.log('üöÄ Queueing AI analysis request...');
      console.log(`üìä Queue status: ${aiRequestQueue.getQueueLength()} pending, ${aiRequestQueue.isProcessing() ? 'processing' : 'idle'}`);
      
      // Use request queue to prevent rate limiting
      return await aiRequestQueue.add(async () => {
        console.log('ü§ñ Processing AI analysis with GitHub Models...');
        return await analyzeWithGitHubModels(remarks, submissions, githubToken);
      });
    } catch (error) {
      console.error('‚ùå GitHub Models API failed, using fallback analysis:', error);
    }
  } else {
    console.warn('‚ö†Ô∏è No GitHub token found. Set VITE_GITHUB_TOKEN in .env file. Using basic fallback analysis.');
  }
  
  // Fallback to local analysis
  return generateFallbackInsights(submissions);
}

/**
 * Uses GitHub Models API to analyze remarks
 */
async function analyzeWithGitHubModels(
  remarks: string[], 
  submissions: any[], 
  token: string
): Promise<InsightResult> {
  // Use local proxy server to avoid CORS issues
  // The proxy runs on localhost:3002 and forwards requests to GitHub Models
  const endpoint = 'http://localhost:3002/api/ai/analyze';
  
  console.log('üåê Using proxy endpoint:', endpoint);
  
  // Collect detailed response data for root cause analysis
  const responseData: { [key: string]: { scores: number[], remarks: string[] } } = {};
  
  submissions.forEach(sub => {
    for (let i = 1; i <= 12; i++) {
      const qKey = `q${i}`;
      const remarkKey = `${qKey}_remarks`;
      
      if (!responseData[qKey]) {
        responseData[qKey] = { scores: [], remarks: [] };
      }
      
      const score = parseScore(sub[qKey]);
      if (score > 0) {
        responseData[qKey].scores.push(score);
      }
      
      const remark = sub[remarkKey];
      if (remark && String(remark).trim().length > 5) {
        responseData[qKey].remarks.push(String(remark).trim());
      }
    }
    
    // Q11 suggestions
    if (sub.q11 && String(sub.q11).trim().length > 5) {
      if (!responseData['q11']) responseData['q11'] = { scores: [], remarks: [] };
      responseData['q11'].remarks.push(String(sub.q11).trim());
    }
  });
  
  // Calculate averages and prepare detailed analysis data
  const questionAnalysis = Object.entries(responseData).map(([q, data]) => {
    const avg = data.scores.length > 0 
      ? (data.scores.reduce((a, b) => a + b, 0) / data.scores.length).toFixed(1)
      : 'N/A';
    return {
      question: q,
      avgScore: avg,
      remarkCount: data.remarks.length,
      sampleRemarks: data.remarks.slice(0, 3)
    };
  }).filter(q => q.remarkCount > 0 || q.avgScore !== 'N/A');
  
  // Question context with reverse scoring info
  const questionContext = `
Question Details (1-5 scale where 5 is best, unless noted):
Q1: Work pressure and staffing adequacy (REVERSE: 5=never pressured/well-staffed, 1=always pressured/understaffed) - Relates to barista staffing during coffee rush hours
Q2: Empowerment in customer service decisions - Can baristas/shift managers make decisions to serve customers without constant approval
Q3: Regular feedback from Area Manager - How often AM provides guidance and performance feedback
Q4: Fair treatment by management (REVERSE: 5=always fair treatment, 1=unfair treatment/favoritism) - Equal opportunities and respect for all staff
Q5: Training program quality (Wings/ZingLearn) - Effectiveness of barista training on coffee preparation, customer service, systems
Q6: Apps/systems/benefits issues (REVERSE: 5=no issues, 1=many issues) - ZingLearn app, POS systems, leave portal, salary processing problems
Q7: HR handbook and policy awareness - Understanding of TWC policies (leave, OT, meals, RESPECT values, etc.)
Q8: Work schedule satisfaction - Happiness with shift timings, weekly offs (4/month), work-life balance
Q9: Team collaboration quality - How well baristas and shift managers work together during shifts
Q10: Helpful colleague recognition (text response) - Naming peers who provide great support
Q11: Improvement suggestions (text response) - Staff ideas for making TWC caf√©s better workplaces
Q12: Overall TWC caf√© experience - General satisfaction working at Third Wave Coffee
`;
  
  // Prepare root cause analysis prompt
  const prompt = `Perform DETAILED ROOT CAUSE ANALYSIS on employee survey data to identify SPECIFIC underlying factors.

${questionContext}

Question-wise Analysis:
${questionAnalysis.map(q => `
${q.question}: Avg Score ${q.avgScore}/5 (${q.remarkCount} remarks)
Sample remarks: ${q.sampleRemarks.map(r => `"${r}"`).join(', ')}
`).join('\n')}

ANALYSIS REQUIREMENTS:
1. Identify SPECIFIC operational, managerial, or systemic root causes
2. Connect score patterns to underlying business factors
3. Look for correlations between related questions (e.g., Q1+Q8 = workload management)
4. Extract actionable insights from employee language patterns
5. Focus on CONCRETE causes, NOT vague descriptions

ROOT CAUSE CATEGORIES to consider:
- Staffing levels & workload distribution
- Management communication & feedback frequency  
- System/technology reliability & functionality
- Training program design & delivery methods
- Policy clarity & implementation consistency
- Work schedule flexibility & break management
- Team dynamics & collaboration processes

For POSITIVES: Identify what management/operational practices are working well
For NEGATIVES: Identify what specific processes/systems need improvement

AVOID generic terms like "poor content", "bad management", "issues"
USE specific terms like "understaffing during peak hours", "infrequent manager check-ins", "app crashes during transactions"

Format: "[Main Issue]: [Simple explanation]" (max 120 chars for better detail)

Examples:
‚úì "Good staffing levels: We have enough people working during busy times so nobody feels too much pressure"  
‚úì "Manager talks regularly: Area manager meets with staff every week to give feedback and help solve problems"
‚úì "App keeps crashing: The computer system stops working often which makes it hard to serve customers quickly"
‚úó "Poor content" or "Bad management" or "Issues exist"

Use SIMPLE, CLEAR language that anyone can understand.

Return ONLY valid JSON with both short summaries AND detailed explanations:
{
  "positives": [
    {
      "summary": "Short title for the positive thing",
      "explanation": "Detailed explanation in simple English about why this is good and what causes it to work well"
    },
    {
      "summary": "Short title for the positive thing", 
      "explanation": "Detailed explanation in simple English about why this is good and what causes it to work well"
    },
    {
      "summary": "Short title for the positive thing",
      "explanation": "Detailed explanation in simple English about why this is good and what causes it to work well"
    }
  ],
  "negatives": [
    {
      "summary": "Short title for the problem",
      "explanation": "Detailed explanation in simple English about what causes this problem and why it happens"
    },
    {
      "summary": "Short title for the problem",
      "explanation": "Detailed explanation in simple English about what causes this problem and why it happens"  
    },
    {
      "summary": "Short title for the problem",
      "explanation": "Detailed explanation in simple English about what causes this problem and why it happens"
    }
  ]
}`;

  const response = await fetch(endpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`
    },
    body: JSON.stringify({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: `You are an expert workplace analyst for Third Wave Coffee (TWC), a specialty coffee chain in India. You analyze employee survey data to identify specific operational, management, and workplace issues.

COMPANY CONTEXT - Third Wave Coffee (TWC):
- Specialty coffee chain operating caf√© stores across India (North, South, East, West regions)
- Store ID format: S### (e.g., S056 Mall of India, S016 Jayanagar, S153 Lajpat Nagar)
- Focus: Premium coffee experience, barista excellence, customer service

STAFF ROLES & HIERARCHY:
- Barista (caf√© staff, partner) - Front-line team member preparing coffee and serving customers
- Buddy Trainer - Peer mentor who trains new hires on coffee preparation and customer service
- Shift Manager (shift lead, floor lead) - Manages day-to-day caf√© operations during shifts
- Area Manager (AM) - Oversees multiple stores in a geographical area
- Regional Manager (RM) - Manages regional operations and multiple Area Managers
- HRBP (HR Partner) - Handles employee relations, engagement, and HR matters for stores
- Trainer/L&D - Learning & Development team managing training programs

KEY TWC PROGRAMS:
- RESPECT Values: Core values framework with digital badges (Responsibility, Empathy, Service Excellence, Performance with Purpose, Ethics, Collaboration, Trust)
- ZingLearn LMS: Digital learning management system and communication platform
- Orientation Online: Digital onboarding program for new hires
- Bench Planning: Talent pipeline and succession planning for career progression
- HR Connect: 15-minute one-on-one employee check-in conversations

COFFEE OPERATIONS:
- Peak Hours: Morning coffee rush (7-11 AM), evening rush (4-7 PM)
- Core Activities: Espresso preparation, milk steaming, latte art, coffee quality control, equipment maintenance, inventory management, customer interaction
- Critical Equipment: Espresso machines, coffee grinders, brewing equipment, milk steamers
- Coffee Standards: Bean quality, grind consistency, extraction time, milk temperature, drink presentation

COMMON TWC-SPECIFIC ISSUES TO IDENTIFY:
Operational:
- Staffing shortages during morning/evening coffee rush hours
- Espresso machine or grinder breakdowns affecting service
- ZingLearn app/system issues preventing training or communication
- Inventory delays for coffee beans, milk, or supplies
- Training gaps in barista skills (espresso extraction, milk steaming, latte art)
- Work schedule conflicts or insufficient weekly offs

Management:
- Area Manager visit frequency and quality of support
- Feedback regularity from AM to barista/shift manager
- Recognition through RESPECT badges or appreciation programs
- Fairness in treatment, promotions, and opportunities
- Communication clarity on policies, changes, or expectations

HR & Workplace:
- Leave approval delays (EL - Earned Leave, FL - Flexi Leave)
- Overtime payment issues (OT applies after +30 min beyond shift)
- Work-life balance concerns (9-hour shifts with 1-hour break, 4 weekly offs/month)
- HRBP responsiveness to store concerns
- Meal policy implementation (2 beverages + 1 food per working day)

Team & Culture:
- Team collaboration and peer support
- Store environment and workplace safety
- Career growth opportunities (Barista ‚Üí Buddy ‚Üí Shift Manager progression)
- Empowerment in decision-making for customer service

ANALYSIS APPROACH:
- Use SPECIFIC coffee shop terminology (barista, espresso, grinder, steamer, rush hour, etc.)
- Reference TWC-specific systems (ZingLearn, RESPECT badges, HR Connect, Bench Planning)
- Identify root causes related to coffee shop operations, not general restaurant issues
- Connect survey scores to actual caf√© operational factors
- Use clear, simple language that TWC caf√© staff will understand
- Consider coffee industry specifics (quality standards, equipment uptime, barista skills)

AVOID:
- Generic restaurant terms (kitchen, food preparation, waitstaff)
- Vague statements like "bad management" or "poor content"
- Unactionable feedback
- Non-coffee industry terminology

OUTPUT FORMAT:
- Summary: Clear, specific title using TWC context (e.g., "Not enough baristas during morning rush", "Espresso machine keeps breaking", "Need more training on latte art")
- Explanation: Simple details about WHY this happens in a caf√© context and its impact on daily coffee shop work

Always respond with valid JSON only.`
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.3,
      max_tokens: 500
    })
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error('GitHub Models API error:', response.status, errorText);
    throw new Error(`GitHub Models API error: ${response.status}`);
  }

  const data = await response.json();
  const content = data.choices?.[0]?.message?.content || '';
  
  console.log('AI Root Cause Analysis:', content);
  
  // Parse JSON from response
  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if (jsonMatch) {
    try {
      const parsed = JSON.parse(jsonMatch[0]);
      
      // Remove any duplicate items based on summary text
      const uniquePositives = removeDuplicates(parsed.positives || []);
      const uniqueNegatives = removeDuplicates(parsed.negatives || []);
      
      // Convert new format to existing format for compatibility
      const positives = uniquePositives.slice(0, 3).map((item: any) => {
        if (typeof item === 'string') return item;
        return item.summary;  // Just use summary, explanation will be in detailedInsights
      });
      
      const negatives = uniqueNegatives.slice(0, 3).map((item: any) => {
        if (typeof item === 'string') return item;
        return item.summary;  // Just use summary, explanation will be in detailedInsights
      });
      
      return {
        positives,
        negatives,
        isAiGenerated: true,
        detailedInsights: {
          positives: uniquePositives.slice(0, 3),
          negatives: uniqueNegatives.slice(0, 3)
        }
      };
    } catch (e) {
      console.error('Failed to parse AI JSON:', e);
    }
  }
  
  throw new Error('Could not parse AI response');
}

/**
 * Fetches training audit data for AM's stores to enhance insights
 */
async function fetchTrainingDataForAM(submissions: any[]): Promise<any[]> {
  try {
    // Dynamic import to avoid circular dependencies
    const { fetchTrainingData } = await import('./dataService');
    
    // Get all training audit data
    const allTrainingData = await fetchTrainingData();
    
    // Extract unique store IDs from HR Connect submissions
    const submissionStoreIds = new Set<string>();
    submissions.forEach(sub => {
      if (sub.store_id || sub.storeId) {
        const storeId = (sub.store_id || sub.storeId).toString();
        submissionStoreIds.add(storeId);
        // Also add S-prefixed version
        if (!storeId.startsWith('S')) {
          submissionStoreIds.add(`S${storeId.padStart(3, '0')}`);
        }
      }
    });
    
    console.log(`üìä Filtering training data for stores:`, Array.from(submissionStoreIds));
    
    // Filter training data for relevant stores
    const relevantTrainingData = allTrainingData.filter(audit => {
      const auditStoreId = (audit.storeId || '').toString();
      return submissionStoreIds.has(auditStoreId) || 
             submissionStoreIds.has(auditStoreId.replace(/^S0*/, ''));
    });
    
    console.log(`‚úÖ Found ${relevantTrainingData.length} training audits for ${submissionStoreIds.size} stores`);
    
    return relevantTrainingData;
  } catch (error) {
    console.error('‚ö†Ô∏è Could not fetch training data:', error);
    return [];
  }
}

/**
 * Analyzes training audit data to generate training-specific insights
 */
function analyzeTrainingData(trainingAudits: any[]): {
  positives: Array<{ theme: string, explanation: string, count: number }>,
  negatives: Array<{ theme: string, explanation: string, count: number }>
} {
  const positives: Array<{ theme: string, explanation: string, count: number }> = [];
  const negatives: Array<{ theme: string, explanation: string, count: number }> = [];
  
  if (trainingAudits.length === 0) {
    return { positives, negatives };
  }
  
  // Calculate average scores across all audits
  let totalScores = 0;
  let totalPercentages = 0;
  let tsaCoffeeScores: number[] = [];
  let tsaFoodScores: number[] = [];
  let tsaCXScores: number[] = [];
  
  // Count specific issues
  let missingMaterials = 0;
  let lmsIssues = 0;
  let buddyTrainingGood = 0;
  let newJoinerTrainingGood = 0;
  
  trainingAudits.forEach(audit => {
    // Overall score
    const percentage = parseFloat(audit.percentageScore || audit.percentage || '0');
    if (percentage > 0) {
      totalPercentages += percentage;
      totalScores++;
    }
    
    // TSA Scores (Training Store Audit)
    const tsaCoffee = parseFloat(audit.tsaCoffeeScore || audit.TSA_Coffee_Score || '0');
    const tsaFood = parseFloat(audit.tsaFoodScore || audit.TSA_Food_Score || '0');
    const tsaCX = parseFloat(audit.tsaCXScore || audit.TSA_CX_Score || '0');
    
    if (tsaCoffee > 0) tsaCoffeeScores.push(tsaCoffee);
    if (tsaFood > 0) tsaFoodScores.push(tsaFood);
    if (tsaCX > 0) tsaCXScores.push(tsaCX);
    
    // Training Materials (TM_1 to TM_9) - check for missing materials
    for (let i = 1; i <= 9; i++) {
      const tmKey = `TM_${i}`;
      const value = String(audit[tmKey] || '').toLowerCase();
      if (value === 'no' || value === '0' || value === 'missing') {
        missingMaterials++;
      }
    }
    
    // LMS Usage (LMS_1 to LMS_3) - check for issues
    for (let i = 1; i <= 3; i++) {
      const lmsKey = `LMS_${i}`;
      const value = String(audit[lmsKey] || '').toLowerCase();
      if (value === 'no' || value === '0' || value.includes('issue') || value.includes('problem')) {
        lmsIssues++;
      }
    }
    
    // Buddy Training (Buddy_1 to Buddy_6) - check for good performance
    let buddyYesCount = 0;
    for (let i = 1; i <= 6; i++) {
      const buddyKey = `Buddy_${i}`;
      const value = String(audit[buddyKey] || '').toLowerCase();
      if (value === 'yes' || value === '1' || value === 'good') {
        buddyYesCount++;
      }
    }
    if (buddyYesCount >= 5) buddyTrainingGood++;
    
    // New Joiner Training (NJ_1 to NJ_7)
    let njYesCount = 0;
    for (let i = 1; i <= 7; i++) {
      const njKey = `NJ_${i}`;
      const value = String(audit[njKey] || '').toLowerCase();
      if (value === 'yes' || value === '1' || value === 'good') {
        njYesCount++;
      }
    }
    if (njYesCount >= 6) newJoinerTrainingGood++;
  });
  
  // Calculate averages
  const avgPercentage = totalScores > 0 ? totalPercentages / totalScores : 0;
  const avgTSACoffee = tsaCoffeeScores.length > 0 ? tsaCoffeeScores.reduce((a, b) => a + b, 0) / tsaCoffeeScores.length : 0;
  const avgTSAFood = tsaFoodScores.length > 0 ? tsaFoodScores.reduce((a, b) => a + b, 0) / tsaFoodScores.length : 0;
  const avgTSACX = tsaCXScores.length > 0 ? tsaCXScores.reduce((a, b) => a + b, 0) / tsaCXScores.length : 0;
  
  console.log(`üìä Training Analysis: Avg=${avgPercentage.toFixed(1)}%, TSA Coffee=${avgTSACoffee.toFixed(1)}/10, Food=${avgTSAFood.toFixed(1)}/10, CX=${avgTSACX.toFixed(1)}/10`);
  
  // Generate insights based on training data
  
  // POSITIVES
  if (avgPercentage >= 85) {
    positives.push({
      theme: 'Excellent training audit scores',
      explanation: `Cafes are scoring very high (${avgPercentage.toFixed(0)}%) on training audits. This shows that baristas are well-trained and follow proper coffee preparation standards, training materials are available, and buddy training is working effectively.`,
      count: avgPercentage
    });
  }
  
  if (avgTSACoffee >= 8) {
    positives.push({
      theme: 'Strong coffee preparation skills',
      explanation: `Training Store Audit scores for coffee are excellent (${avgTSACoffee.toFixed(1)}/10). Baristas demonstrate good espresso extraction technique, milk steaming skills, and latte art. This indicates effective coffee training programs.`,
      count: avgTSACoffee * 10
    });
  }
  
  if (buddyTrainingGood >= trainingAudits.length * 0.7) {
    positives.push({
      theme: 'Buddy training program working well',
      explanation: `Buddy training is effective in most cafes. New baristas are getting proper support from experienced peers who teach them coffee preparation, customer service skills, and daily operations. This peer mentoring approach is helping new staff learn faster.`,
      count: buddyTrainingGood * 10
    });
  }
  
  if (newJoinerTrainingGood >= trainingAudits.length * 0.6) {
    positives.push({
      theme: 'Good onboarding for new joiners',
      explanation: `New joiner training program is working well. Fresh baristas are receiving proper orientation about TWC values, coffee standards, equipment usage, and store procedures. This foundation helps them perform better in their roles.`,
      count: newJoinerTrainingGood * 10
    });
  }
  
  // NEGATIVES
  if (avgPercentage > 0 && avgPercentage < 70) {
    negatives.push({
      theme: 'Training audit scores are low',
      explanation: `Cafes are scoring poorly (${avgPercentage.toFixed(0)}%) on training audits. This indicates gaps in barista training, missing training materials, incomplete buddy programs, or lack of proper coffee preparation skills. Immediate training intervention is needed.`,
      count: (100 - avgPercentage)
    });
  }
  
  if (avgTSACoffee > 0 && avgTSACoffee < 6) {
    negatives.push({
      theme: 'Coffee skills need improvement',
      explanation: `Training Store Audit scores for coffee are low (${avgTSACoffee.toFixed(1)}/10). Baristas are struggling with espresso extraction, milk steaming technique, or drink consistency. More hands-on coffee training sessions and practice are required.`,
      count: (10 - avgTSACoffee) * 10
    });
  }
  
  if (avgTSAFood > 0 && avgTSAFood < 6) {
    negatives.push({
      theme: 'Food handling skills need work',
      explanation: `Training Store Audit scores for food are low (${avgTSAFood.toFixed(1)}/10). Staff need better training on food safety, presentation standards, and menu knowledge. This affects customer experience and food quality.`,
      count: (10 - avgTSAFood) * 8
    });
  }
  
  if (missingMaterials >= trainingAudits.length * 2) {
    negatives.push({
      theme: 'Training materials are missing',
      explanation: `Many cafes do not have required training materials like FRM (Food Reference Manual), BRM (Beverage Reference Manual), cue cards, or one-pagers displayed. Without these reference materials, baristas cannot maintain quality standards consistently.`,
      count: missingMaterials * 5
    });
  }
  
  if (lmsIssues >= trainingAudits.length * 0.5) {
    negatives.push({
      theme: 'ZingLearn LMS has problems',
      explanation: `Staff are reporting issues with the ZingLearn learning management system. The app may not be working properly, training modules are incomplete, or staff cannot access required learning content. This prevents proper digital training delivery.`,
      count: lmsIssues * 8
    });
  }
  
  return { positives, negatives };
}

/**
 * Generates insights using local analysis when AI is not available
 */
async function generateFallbackInsights(submissions: any[]): Promise<InsightResult> {
  const positives: Map<string, number> = new Map();
  const negatives: Map<string, number> = new Map();
  
  // Fetch training audit data for AM's stores
  console.log('üéì Fetching training audit data for enhanced insights...');
  const trainingAudits = await fetchTrainingDataForAM(submissions);
  
  // Analyze training data
  const trainingInsights = analyzeTrainingData(trainingAudits);
  console.log(`‚úÖ Generated ${trainingInsights.positives.length} positive and ${trainingInsights.negatives.length} negative training insights`);
  
  // Collect all remarks for frequency analysis
  const allRemarks: string[] = [];
  const scoresByQuestion: { [key: string]: number[] } = {};
  
  submissions.forEach((sub: any) => {
    // Collect remarks
    for (let i = 1; i <= 12; i++) {
      const remarkKey = `q${i}_remarks`;
      const remark = sub[remarkKey];
      if (remark && String(remark).trim().length > 5) {
        allRemarks.push(String(remark).trim().toLowerCase());
      }
      
      // Collect scores
      const scoreKey = `q${i}`;
      const score = parseScore(sub[scoreKey]);
      if (score > 0) {
        if (!scoresByQuestion[scoreKey]) {
          scoresByQuestion[scoreKey] = [];
        }
        scoresByQuestion[scoreKey].push(score);
      }
    }
    
    // Also collect q11 (suggestions)
    if (sub.q11 && String(sub.q11).trim().length > 5) {
      allRemarks.push(String(sub.q11).trim().toLowerCase());
    }
  });

  // Analyze remarks for keywords with detailed root cause themes in simple English
  const positiveKeywords = [
    { 
      words: ['good', 'great', 'excellent', 'satisfied', 'happy'], 
      theme: 'Team is doing well',
      explanation: 'Staff feel happy and satisfied because they are getting good support and the work environment is positive. This happens when managers care about their team and help them succeed.'
    },
    { 
      words: ['support', 'help', 'care', 'understanding', 'friendly'], 
      theme: 'Manager gives good help',
      explanation: 'The area manager is supportive and helps staff when they need it. This makes people feel valued and confident at work. Good managers check on their team regularly and solve problems quickly.'
    },
    { 
      words: ['fair', 'equal', 'respect', 'dignity', 'unbiased'], 
      theme: 'Everyone gets treated fairly',
      explanation: 'All staff members are treated the same way and with respect. This happens when managers follow company rules properly and do not show favoritism to certain people.'
    },
    { 
      words: ['training', 'learn', 'develop', 'skill', 'knowledge'], 
      theme: 'Good training programs',
      explanation: 'Staff are getting proper training that helps them do their job better. This works well when training is clear, practical, and gives people the skills they actually need for their daily work.'
    },
    { 
      words: ['balance', 'flexible', 'schedule', 'time'], 
      theme: 'Good work schedules',
      explanation: 'Work schedules are flexible and allow people to balance their job with personal life. This happens when managers plan shifts properly and consider staff needs when making rosters.'
    },
    { 
      words: ['communication', 'feedback', 'listen', 'talk'], 
      theme: 'Manager talks with staff regularly',
      explanation: 'The area manager communicates well and listens to staff concerns. This creates trust because people know their manager cares about their opinions and will help solve problems.'
    },
    { 
      words: ['team', 'colleague', 'together', 'cooperation'], 
      theme: 'Team works well together',
      explanation: 'Staff members help each other and work as a team. This happens when there is good leadership and everyone understands their role. People feel comfortable asking colleagues for help.'
    },
    { 
      words: ['quick', 'fast', 'prompt', 'immediate'], 
      theme: 'Things get done quickly',
      explanation: 'Work processes are efficient and problems get solved fast. This happens when systems work properly, staff are well-trained, and there are enough people working during busy times.'
    }
  ];
  
  const negativeKeywords = [
    { 
      words: ['pressure', 'stress', 'overwork', 'burden', 'rush'], 
      theme: 'Too much work pressure',
      explanation: 'Staff feel stressed because there is too much work to do in the time given. This usually happens when there are not enough people working during busy times, or when tasks are not shared fairly among the team.'
    },
    { 
      words: ['late', 'delay', 'waiting', 'slow'], 
      theme: 'Things take too long',
      explanation: 'Processes are slow and people have to wait for approvals or systems to work. This creates frustration because staff cannot serve customers quickly or complete their tasks on time.'
    },
    { 
      words: ['partial', 'unfair', 'favorit', 'biased'], 
      theme: 'Some people get better treatment',
      explanation: 'Staff feel that some colleagues get special treatment while others are treated poorly. This happens when managers do not apply rules equally or show favoritism to certain people.'
    },
    { 
      words: ['break', 'rest', 'tired', 'exhausted'], 
      theme: 'Not enough rest time',
      explanation: 'Staff are not getting proper breaks or rest periods during their shifts. This makes people tired and affects their performance. It usually happens when shifts are poorly planned or too busy.'
    },
    { 
      words: ['confused', 'unclear', 'dont know', 'understand'], 
      theme: 'Information is not clear',
      explanation: 'Staff do not understand what they need to do or company policies are confusing. This happens when managers do not explain things properly or information is not shared clearly with the team.'
    },
    { 
      words: ['app', 'system', 'error', 'bug', 'crash'], 
      theme: 'Zing Learning & Zing HR systems have problems',
      explanation: 'The Zing Learning and Zing HR systems and related apps that staff use for work are not working properly. They crash, have errors, or are slow. This makes it difficult to serve customers and complete tasks efficiently.'
    },
    { 
      words: ['salary', 'pay', 'money', 'compensation'], 
      theme: 'Payment problems',
      explanation: 'There are issues with salary payments, bonuses, or other money matters. This could be delays in payment, wrong amounts, or confusion about compensation. This affects staff trust and motivation.'
    },
    { 
      words: ['rude', 'harsh', 'angry', 'shouting'], 
      theme: 'Manager is not friendly',
      explanation: 'The area manager speaks to staff in a rude or harsh way. This makes people feel uncomfortable and affects team morale. Good managers should be respectful and supportive, not aggressive or mean.'
    },
    { 
      words: ['no time', 'busy', 'cant', 'impossible'], 
      theme: 'Not enough time for tasks',
      explanation: 'Staff feel they do not have enough time to complete all their work properly. This happens when there are too many tasks, unrealistic deadlines, or not enough people to share the workload.'
    }
  ];

  // Count keyword occurrences
  const positiveDetails: Map<string, { count: number, explanation: string }> = new Map();
  const negativeDetails: Map<string, { count: number, explanation: string }> = new Map();
  
  positiveKeywords.forEach(({ words, theme, explanation }) => {
    let count = 0;
    allRemarks.forEach(remark => {
      if (words.some(word => remark.includes(word))) {
        count++;
      }
    });
    if (count > 0) {
      positives.set(theme, count);
      positiveDetails.set(theme, { count, explanation });
    }
  });
  
  negativeKeywords.forEach(({ words, theme, explanation }) => {
    let count = 0;
    allRemarks.forEach(remark => {
      if (words.some(word => remark.includes(word))) {
        count++;
      }
    });
    if (count > 0) {
      negatives.set(theme, count);
      negativeDetails.set(theme, { count, explanation });
    }
  });

  // Analyze scores by question with detailed root cause themes
  const questionThemes: { [key: string]: { 
    positive: { theme: string, explanation: string }, 
    negative: { theme: string, explanation: string } 
  } } = {
    q1: { 
      positive: { theme: 'Good staffing levels', explanation: 'There are enough people working during busy times so staff do not feel too much pressure. Managers plan the workforce well and make sure no one is overworked.' },
      negative: { theme: 'Not enough staff during busy times', explanation: 'There are too few people working when it gets busy, which puts pressure on everyone. This happens when managers do not plan properly for rush hours or busy periods.' }
    },
    q2: { 
      positive: { theme: 'Staff can make decisions', explanation: 'Employees are allowed to make important decisions when helping customers without always asking for permission. This makes work faster and more efficient.' },
      negative: { theme: 'Staff cannot decide things', explanation: 'Employees have to ask permission for too many small decisions, which slows down customer service. The approval process is too strict and takes too long.' }
    },
    q3: { 
      positive: { theme: 'Manager gives regular feedback', explanation: 'The area manager talks to staff regularly and gives helpful feedback about their work. This helps people improve and feel supported in their job.' },
      negative: { theme: 'Manager does not talk enough', explanation: 'The area manager does not meet with staff often enough or give feedback about their performance. People feel ignored and do not know how they are doing at work.' }
    },
    q4: { 
      positive: { theme: 'Everyone is treated fairly', explanation: 'All staff members get the same treatment and opportunities. The manager follows company rules equally for everyone and does not show favoritism.' },
      negative: { theme: 'Some people get better treatment', explanation: 'The manager treats some staff better than others, which is not fair. This creates jealousy and makes people feel unvalued or discriminated against.' }
    },
    q5: { 
      positive: { theme: 'Training programs work well', explanation: 'The training that staff receive is helpful and teaches them what they need to know for their job. The programs are well-organized and easy to understand.' },
      negative: { theme: 'Training programs have problems', explanation: 'The training is not helpful or well-organized. Staff do not learn what they need to know, or the training methods are confusing and ineffective.' }
    },
    q6: { 
      positive: { theme: 'Zing Learning & Zing HR systems work well', explanation: 'The Zing Learning and Zing HR systems and related apps that staff use are reliable and work properly. This helps people do their job efficiently without technical problems.' },
      negative: { theme: 'Zing Learning & Zing HR systems keep breaking', explanation: 'The Zing Learning and Zing HR systems and related apps have problems like crashes, errors, or slow performance. This makes it difficult for staff to serve customers and complete their work.' }
    },
    q7: { 
      positive: { theme: 'Company information is clear', explanation: 'Staff understand company policies and procedures because information is shared clearly and regularly. Everyone knows what the rules are and how to follow them.' },
      negative: { theme: 'Company information is confusing', explanation: 'Staff do not understand company policies or procedures because information is not shared clearly. People are confused about what they should do or what the rules are.' }
    },
    q8: { 
      positive: { theme: 'Work schedules are good', explanation: 'Staff are happy with their work schedules because they are flexible and fair. Managers consider people\'s needs when making rosters and allow for work-life balance.' },
      negative: { theme: 'Work schedules are bad', explanation: 'Staff are unhappy with their schedules because they are too rigid or unfair. Managers do not consider people\'s personal needs when making rosters.' }
    },
    q9: { 
      positive: { theme: 'Team works well together', explanation: 'Staff members help each other and communicate well as a team. There is good cooperation and people feel comfortable working with their colleagues.' },
      negative: { theme: 'Team does not work well together', explanation: 'There are problems with teamwork and communication between staff members. People do not help each other or there are conflicts that affect the work environment.' }
    },
    q12: { 
      positive: { theme: 'Overall experience is very good', explanation: 'Staff have a positive experience working for the company because many things are working well together - good management, fair treatment, proper support, and a positive work environment.' },
      negative: { theme: 'Overall experience has many problems', explanation: 'Staff have a negative experience because there are multiple problems affecting their work - poor management, unfair treatment, lack of support, or a negative work environment.' }
    }
  };

  // Add themes based on scores
  Object.entries(scoresByQuestion).forEach(([qKey, scores]) => {
    if (scores.length === 0) return;
    
    const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;
    const theme = questionThemes[qKey];
    
    if (!theme) return;
    
    // High scores (>= 3.8) are very positive
    if (avgScore >= 3.8) {
      positives.set(theme.positive.theme, avgScore * 10);
      positiveDetails.set(theme.positive.theme, { count: avgScore * 10, explanation: theme.positive.explanation });
    } 
    // Low scores (<= 2.5) are negative
    else if (avgScore <= 2.5) {
      negatives.set(theme.negative.theme, (5 - avgScore) * 10);
      negativeDetails.set(theme.negative.theme, { count: (5 - avgScore) * 10, explanation: theme.negative.explanation });
    }
    // Medium-low scores (2.5-3.2) are mild concerns
    else if (avgScore <= 3.2) {
      negatives.set(theme.negative.theme, (4 - avgScore) * 5);
      negativeDetails.set(theme.negative.theme, { count: (4 - avgScore) * 5, explanation: theme.negative.explanation });
    }
  });

  // Merge training insights with HR Connect insights
  trainingInsights.positives.forEach(insight => {
    positives.set(insight.theme, insight.count);
    positiveDetails.set(insight.theme, { count: insight.count, explanation: insight.explanation });
  });
  
  trainingInsights.negatives.forEach(insight => {
    negatives.set(insight.theme, insight.count);
    negativeDetails.set(insight.theme, { count: insight.count, explanation: insight.explanation });
  });

  // Get top 3 of each, sorted by frequency/score
  const topPositives = Array.from(positives.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3)
    .map(([text]) => text);
  
  const topNegatives = Array.from(negatives.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3)
    .map(([text]) => text);

  // Ensure we always have exactly 3 items with detailed root cause format
  const defaultPositives = [
    { theme: 'Work processes are stable', explanation: 'The daily work routines and processes are consistent and reliable. Staff know what to do and can deliver good service to customers regularly.' },
    { theme: 'Good work environment', explanation: 'People enjoy working here because there is a positive atmosphere. Staff feel comfortable and supported by their colleagues and managers.' }, 
    { theme: 'Basic training is adequate', explanation: 'Staff receive enough basic training to do their job properly. They understand the main tasks and company standards that are needed for their work.' }
  ];
  
  const defaultNegatives = [
    { theme: 'Need more feedback from staff', explanation: 'The company should ask staff for their opinions more often through surveys or meetings. This would help identify problems early and improve the workplace.' },
    { theme: 'Information sharing needs improvement', explanation: 'Communication between management and staff could be better. People need clearer and more regular updates about company news, changes, and expectations.' },
    { theme: 'More regular check-ins needed', explanation: 'Managers should meet with their staff more often to discuss performance and provide support. Regular one-on-one meetings would help solve problems faster.' }
  ];

  // Create detailed insights from the analysis
  const detailedPositivesArray = Array.from(positiveDetails.entries())
    .sort((a, b) => b[1].count - a[1].count)
    .slice(0, 3)
    .map(([theme, data]) => ({ summary: theme, explanation: data.explanation }));

  const detailedNegativesArray = Array.from(negativeDetails.entries())
    .sort((a, b) => b[1].count - a[1].count)
    .slice(0, 3)
    .map(([theme, data]) => ({ summary: theme, explanation: data.explanation }));

  // Ensure we have 3 items
  while (detailedPositivesArray.length < 3) {
    const defaultItem = defaultPositives[detailedPositivesArray.length];
    detailedPositivesArray.push({ summary: defaultItem.theme, explanation: defaultItem.explanation });
  }
  while (detailedNegativesArray.length < 3) {
    const defaultItem = defaultNegatives[detailedNegativesArray.length];
    detailedNegativesArray.push({ summary: defaultItem.theme, explanation: defaultItem.explanation });
  }

  return {
    positives: topPositives.length >= 3 ? topPositives : [...topPositives, ...defaultPositives.map(d => d.theme)].slice(0, 3),
    negatives: topNegatives.length >= 3 ? topNegatives : [...topNegatives, ...defaultNegatives.map(d => d.theme)].slice(0, 3),
    isAiGenerated: false,
    detailedInsights: {
      positives: detailedPositivesArray.slice(0, 3),
      negatives: detailedNegativesArray.slice(0, 3)
    }
  };
}

/**
 * Parses score from various formats
 */
function parseScore(value: any): number {
  if (!value) return 0;
  
  const str = String(value).toLowerCase().trim();
  
  // Map text responses to scores
  const scoreMap: { [key: string]: number } = {
    'never': 5,
    'at time': 4,
    'sometime': 3,
    'most of the time': 2,
    'every time': 1,
    'excellent': 5,
    'very good': 4,
    'good': 3,
    'average': 2,
    'poor': 1
  };
  
  // Check if it's a text response
  for (const [key, score] of Object.entries(scoreMap)) {
    if (str === key) {
      return score;
    }
  }
  
  // Try to parse as number
  const num = parseFloat(str);
  return isNaN(num) ? 0 : num;
}

/**
 * Cache for AI insights to avoid repeated API calls
 */
const insightsCache = new Map<string, { insights: InsightResult; timestamp: number }>();
const CACHE_DURATION = 7 * 24 * 60 * 60 * 1000; // 7 days - aggressive caching to minimize API calls

/**
 * Analyzes monthly submission data for detailed insights
 * @param monthName - Name of the month
 * @param submissions - Submissions for that specific month
 * @returns Promise with monthly insights
 */
export async function generateMonthlyInsights(monthName: string, submissions: any[]): Promise<InsightResult> {
  try {
    console.log(`üìä [${monthName}] Using enhanced fallback analysis (AI disabled)`);
    
    // If no submissions, return default
    if (submissions.length === 0) {
      return {
        positives: [`No data for ${monthName}`],
        negatives: [`No submissions recorded for ${monthName}`],
        isAiGenerated: false,
        detailedInsights: {
          positives: [{
            summary: `No data for ${monthName}`,
            explanation: `There were no survey submissions recorded for ${monthName}. This could mean staff were not surveyed during this period or responses were not collected properly.`
          }],
          negatives: [{
            summary: `No feedback collected`,
            explanation: `Without survey data, it is difficult to understand how staff felt during ${monthName}. Regular feedback collection helps identify both successes and areas that need improvement.`
          }]
        }
      };
    }

    // Always use fallback analysis for reliability
    return generateMonthlyFallback(monthName, submissions);
    
  } catch (error) {
    console.error(`Error generating monthly insights for ${monthName}:`, error);
    return generateMonthlyFallback(monthName, submissions);
  }
}

/**
 * Calculates statistics for a specific month
 */
function calculateMonthStats(submissions: any[]) {
  const stats: { [key: string]: { scores: number[], avg: number } } = {};
  
  submissions.forEach(sub => {
    for (let i = 1; i <= 12; i++) {
      const qKey = `q${i}`;
      const score = parseScore(sub[qKey]);
      
      if (score > 0) {
        if (!stats[qKey]) {
          stats[qKey] = { scores: [], avg: 0 };
        }
        stats[qKey].scores.push(score);
      }
    }
  });
  
  // Calculate averages
  Object.keys(stats).forEach(qKey => {
    const scores = stats[qKey].scores;
    stats[qKey].avg = scores.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : 0;
  });
  
  return stats;
}

/**
 * Extracts remarks from submissions
 */
function extractRemarks(submissions: any[]): string[] {
  const remarks: string[] = [];
  
  submissions.forEach(sub => {
    for (let i = 1; i <= 12; i++) {
      const remarkKey = `q${i}_remarks`;
      const remark = sub[remarkKey];
      if (remark && String(remark).trim().length > 5) {
        remarks.push(String(remark).trim());
      }
    }
    
    if (sub.q11 && String(sub.q11).trim().length > 5) {
      remarks.push(String(sub.q11).trim());
    }
  });
  
  return remarks;
}

/**
 * Uses AI to analyze monthly data
 */
async function analyzeMonthWithAI(monthName: string, submissions: any[], monthStats: any, remarks: string[]): Promise<InsightResult> {
  const githubToken = import.meta.env.VITE_GITHUB_TOKEN || '';
  
  console.log(`üîç [${monthName}] Checking GitHub token:`, githubToken ? '‚úÖ Available' : '‚ùå Missing');
  
  if (githubToken && githubToken.length > 10) {
    try {
      console.log(`üöÄ [${monthName}] Queueing AI analysis...`);
      console.log(`üìä Queue status: ${aiRequestQueue.getQueueLength()} pending`);
      
      // Use request queue to prevent rate limiting
      return await aiRequestQueue.add(async () => {
        console.log(`ü§ñ [${monthName}] Processing AI analysis...`);
        return await analyzeMonthWithGitHubModels(monthName, submissions, monthStats, remarks, githubToken);
      });
    } catch (error) {
      console.error(`‚ùå [${monthName}] GitHub Models API failed:`, error);
    }
  } else {
    console.warn(`‚ö†Ô∏è [${monthName}] No GitHub token. Using basic fallback analysis.`);
  }
  
  return generateMonthlyFallback(monthName, submissions);
}

/**
 * AI analysis for monthly data
 */
async function analyzeMonthWithGitHubModels(
  monthName: string, 
  submissions: any[], 
  monthStats: any, 
  remarks: string[], 
  token: string
): Promise<InsightResult> {
  // Use local proxy server to avoid CORS issues
  const endpoint = 'http://localhost:3002/api/ai/analyze';
  
  console.log(`üåê [${monthName}] Using proxy endpoint:`, endpoint);
  
  // Prepare month-specific analysis
  const monthSummary = Object.entries(monthStats).map(([q, data]: [string, any]) => {
    return `${q}: Average ${data.avg.toFixed(1)}/5 (${data.scores.length} responses)`;
  }).join('\n');
  
  const sampleRemarks = remarks.slice(0, 6).map(r => `"${r}"`).join(', ');
  
  const prompt = `Analyze survey data for ${monthName} and provide ROOT CAUSE ANALYSIS.

Month: ${monthName}
Total Submissions: ${submissions.length}

Question Averages:
${monthSummary}

Sample Employee Remarks:
${sampleRemarks}

Task: Identify what specifically happened in ${monthName} that caused positive and negative experiences.

Consider:
- What operational factors influenced this month's results?
- What management practices were working well or poorly?
- What system or process issues affected staff experience?
- What seasonal or business factors might have impacted performance?

Use SIMPLE ENGLISH that anyone can understand. Explain like talking to someone new to the company.

Format: Brief title + detailed explanation (max 150 chars for title)

Return ONLY valid JSON:
{
  "positives": [
    {
      "summary": "What went well in ${monthName}",
      "explanation": "Detailed explanation in simple terms about why this positive thing happened during this specific month"
    },
    {
      "summary": "Another positive factor",
      "explanation": "Clear explanation of what caused this good outcome in ${monthName}"
    },
    {
      "summary": "Third positive aspect", 
      "explanation": "Simple explanation of why this worked well during ${monthName}"
    }
  ],
  "negatives": [
    {
      "summary": "What caused problems in ${monthName}",
      "explanation": "Clear explanation in simple words about what went wrong and why it happened during this month"
    },
    {
      "summary": "Another issue in ${monthName}",
      "explanation": "Detailed but simple explanation of what caused this problem during this specific month"
    },
    {
      "summary": "Third concern",
      "explanation": "Easy-to-understand explanation of what led to this issue in ${monthName}"
    }
  ]
}`;

  const response = await fetch(endpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`
    },
    body: JSON.stringify({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: `You are an expert workplace analyst for Third Wave Coffee (TWC), a specialty coffee chain in India. You analyze monthly employee survey data to identify trends, operational patterns, and management effectiveness for specific time periods.

TWC CONTEXT:
- Specialty coffee shop operations with peak hours (morning coffee rush 7-11 AM, evening rush 4-7 PM)
- Caf√© staff (baristas, shift managers) managed by Area Managers with HRBP support
- Monthly HR Connect surveys measure employee satisfaction across coffee shop operations
- Common factors: barista staffing during rush hours, espresso machine/grinder uptime, manager support, coffee training quality (ZingLearn), work schedules and weekly offs
- TWC Programs: RESPECT values/badges, ZingLearn LMS, Orientation, Bench Planning, HR Connect check-ins
- Key Policies: 9-hour shifts with 1-hour break, 4 weekly offs/month, EL (24 days), FL (12-14 days), OT after +30 min, meal policy (2 beverages + 1 food)

MONTHLY ANALYSIS FOCUS:
- Seasonal factors (festival seasons, weather affecting coffee consumption, holiday staffing)
- Operational changes during that month (new equipment, ZingLearn updates, policy changes)
- Specific incidents or patterns unique to that time period (equipment failures, training rollouts, AM changes)
- Month-over-month improvements or declines in key metrics
- Short-term vs long-term issues in coffee shop operations
- Coffee quality initiatives or barista training programs launched that month

Use TWC-specific terminology and coffee shop operations context (barista, espresso, grinder, steamer, rush hours, caf√©, ZingLearn, RESPECT badges, etc.). Explain in simple, clear language what specifically happened during the given month in the context of running specialty coffee caf√©s.

Always respond with valid JSON only.`
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.3,
      max_tokens: 800
    })
  });

  if (!response.ok) {
    throw new Error(`GitHub Models API error: ${response.status}`);
  }

  const data = await response.json();
  const content = data.choices?.[0]?.message?.content || '';
  
  // Parse JSON response
  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if (jsonMatch) {
    try {
      const parsed = JSON.parse(jsonMatch[0]);
      
      // Remove duplicates
      const uniquePositives = removeDuplicates(parsed.positives || []);
      const uniqueNegatives = removeDuplicates(parsed.negatives || []);
      
      const positives = uniquePositives.slice(0, 3).map((item: any) => {
        if (typeof item === 'string') return item;
        return item.summary;
      });
      
      const negatives = uniqueNegatives.slice(0, 3).map((item: any) => {
        if (typeof item === 'string') return item;
        return item.summary;
      });
      
      return {
        positives,
        negatives,
        isAiGenerated: true,
        detailedInsights: {
          positives: uniquePositives.slice(0, 3),
          negatives: uniqueNegatives.slice(0, 3)
        }
      };
    } catch (e) {
      console.error('Failed to parse monthly AI JSON:', e);
    }
  }
  
  throw new Error('Could not parse monthly AI response');
}

/**
 * Fallback analysis for monthly data
 */
function generateMonthlyFallback(monthName: string, submissions: any[]): InsightResult {
  const monthStats = calculateMonthStats(submissions);
  const remarks = extractRemarks(submissions);
  
  // Simple analysis based on scores and keywords
  const avgScores = Object.values(monthStats).map((stat: any) => stat.avg).filter(avg => avg > 0);
  const overallAvg = avgScores.length > 0 ? avgScores.reduce((a, b) => a + b, 0) / avgScores.length : 3.0;
  
  let positives: Array<{ summary: string, explanation: string }> = [];
  let negatives: Array<{ summary: string, explanation: string }> = [];
  
  // Score-based analysis
  if (overallAvg >= 3.8) {
    positives.push({
      summary: `Strong performance in ${monthName}`,
      explanation: `Staff gave high ratings across most areas during ${monthName}. This suggests that management practices, work conditions, and support systems were working well during this period.`
    });
  } else if (overallAvg >= 3.2) {
    positives.push({
      summary: `Decent performance in ${monthName}`,
      explanation: `Most staff were reasonably satisfied during ${monthName}. While there were some areas for improvement, the overall experience was positive for most employees.`
    });
  }
  
  if (overallAvg <= 2.5) {
    negatives.push({
      summary: `Multiple concerns in ${monthName}`,
      explanation: `Staff ratings were low across several areas during ${monthName}. This indicates there were significant challenges with work conditions, management support, or operational issues during this period.`
    });
  } else if (overallAvg <= 3.2) {
    negatives.push({
      summary: `Some areas need attention in ${monthName}`,
      explanation: `While not critically low, some aspects of the work experience during ${monthName} could be improved. Staff feedback suggests there were moderate concerns that should be addressed.`
    });
  }
  
  // Keyword analysis from remarks
  const allRemarksText = remarks.join(' ').toLowerCase();
  
  if (allRemarksText.includes('good') || allRemarksText.includes('great') || allRemarksText.includes('happy')) {
    positives.push({
      summary: `Positive feedback during ${monthName}`,
      explanation: `Staff specifically mentioned positive experiences in their comments during ${monthName}. This indicates good management support and work environment during this period.`
    });
  }
  
  if (allRemarksText.includes('problem') || allRemarksText.includes('issue') || allRemarksText.includes('difficult')) {
    negatives.push({
      summary: `Issues reported in ${monthName}`,
      explanation: `Staff mentioned specific problems or difficulties in their feedback during ${monthName}. These concerns should be investigated and addressed to improve future experiences.`
    });
  }
  
  // Ensure we have at least one item in each category
  if (positives.length === 0) {
    positives.push({
      summary: `Regular operations in ${monthName}`,
      explanation: `Work continued normally during ${monthName} with staff completing their daily tasks. While there may not have been outstanding successes, basic operations remained stable.`
    });
  }
  
  if (negatives.length === 0) {
    negatives.push({
      summary: `Limited feedback for ${monthName}`,
      explanation: `There was not enough detailed feedback to identify specific concerns during ${monthName}. More regular check-ins with staff could help identify areas for improvement.`
    });
  }
  
  // Fill to 3 items
  while (positives.length < 3) {
    positives.push({
      summary: `Standard performance maintained`,
      explanation: `Basic work standards and procedures were followed during ${monthName}, ensuring consistent service delivery and operational continuity.`
    });
  }
  
  while (negatives.length < 3) {
    negatives.push({
      summary: `Monitor for improvements`,
      explanation: `Regular monitoring and staff feedback collection during periods like ${monthName} helps identify opportunities for enhancing the work experience.`
    });
  }
  
  return {
    positives: positives.slice(0, 3).map(p => p.summary),
    negatives: negatives.slice(0, 3).map(n => n.summary),
    isAiGenerated: false,
    detailedInsights: {
      positives: positives.slice(0, 3),
      negatives: negatives.slice(0, 3)
    }
  };
}

/**
 * Get insights with caching
 */
export async function getCachedAMInsights(amId: string, submissions: any[]): Promise<InsightResult> {
  const cacheKey = `${amId}_${submissions.length}`;
  const cached = insightsCache.get(cacheKey);
  
  // Check if cache is valid
  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
    console.log('‚úÖ Using cached insights for AM:', amId);
    return cached.insights;
  }
  
  // Generate new insights
  console.log('üîÑ Generating new insights for AM:', amId);
  const insights = await generateAMInsights(submissions);
  
  // Cache the results
  insightsCache.set(cacheKey, {
    insights,
    timestamp: Date.now()
  });
  
  return insights;
}
